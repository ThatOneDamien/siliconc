#define _POSIX_C_SOURCE 200809L
#include "cmdline.h"
#include "core.h"
#include "lexer.h"
#include "parser.h"
#include "backend/codegen.h"
#include "utils/debug.h"
#include "utils/error.h"
#include "utils/file_utils.h"
#include "utils/hash.h"

#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>

static void  output_preprocessed(Token* preprocessed, char* output_path);
static char* compile(Token* preprocessed, char* input_path);
static char* assemble(char* input_path);
static char* create_tempfile(void);
static void  close_tempfiles(void);

static StringArray s_tempfiles;

int main(int argc, char* argv[])
{
    if(argc < 1)
        sic_error_fatal("Bad arguments.");
    
    process_cmdln_args(argc, argv);
    
    for(size_t i = 0; i < args.input_files.size; ++i)
        if(!file_exists(args.input_files.data[i]))
            sic_error_fatal("File named '%s' not found.", args.input_files.data[i]);

    init_parser();
    da_init(&s_tempfiles, args.input_files.size);
    atexit(close_tempfiles); // Close all tempfiles opened when we exit for any reason

    StringArray linker_inputs;
    da_init(&linker_inputs, args.input_files.size);

    for(size_t i = 0; i < args.input_files.size; ++i)
    {
        char* cur_input_path     = args.input_files.data[i];
        char* cur_input_filename = strrchr(cur_input_path, '/');

        FileType ft = get_filetype(cur_input_filename);

        if(ft == FT_SI)
        {
            printf("\n\033[35;1mLEXER:\033[0m\n");
            Token* tokens = lex_file(cur_input_path);
            print_all_tokens(tokens);

            if(args.mode == MODE_PREPROCESS)
            {
                output_preprocessed(tokens, args.output_file);
                continue;
            }

            char* prev_file;
            prev_file = compile(tokens, cur_input_path);
            prev_file = assemble(prev_file);
            if(prev_file != NULL)
                da_append(&linker_inputs, prev_file);
        }
        else if(ft == FT_ASM)
        {
            char* prev_file = assemble(cur_input_path);
            if(prev_file != NULL)
                da_append(&linker_inputs, prev_file)
            else
                fprintf(stderr, "Assembly file \'%s\' was ignored because \'-p\' or \'-c\' was provided.", cur_input_path);
        }
        else if(ft == FT_OBJ)
        {
            if(args.mode == MODE_LINK)
                da_append(&linker_inputs, cur_input_path)
            else
                fprintf(stderr, "Object file \'%s\' was ignored because \'-p\', \'-c\', or \'-s\' was provided.", cur_input_path);
        }
        else
            sic_error_fatal("Input file \'%s\' has invalid extension.", cur_input_path);

    }

    if(args.mode == MODE_LINK)
    {
        // Link the object files generated by the assembly step into the
        // final output for the architecture specified in the command line.
        StringArray cmd;
        da_append(&cmd, "ld");
        da_append(&cmd, "-m");
        da_append(&cmd, "elf_x86_64"); // Change this to depend on the target architecture
        da_append(&cmd, "-o");
        da_append(&cmd, args.output_file ? (char*)args.output_file : "a.out");
        for(size_t i = 0; i < linker_inputs.size; ++i)
            da_append(&cmd, linker_inputs.data[i]);
        da_append(&cmd, NULL);
        run_subprocess(cmd.data);
    }
    return EXIT_SUCCESS;
}

void run_subprocess(char** cmd)
{
    if(fork() == 0)
    {
        execvp(cmd[0], cmd);
        fprintf(stderr, "failed to execute subprocess \'%s\': %s\n", cmd[0], strerror(errno));
        _exit(EXIT_FAILURE);
    }

    int status;
    while(wait(&status) > 0)
        ;
    if(status != EXIT_SUCCESS)
        exit(status);
}

static void output_preprocessed(Token* preprocessed, char* output_path)
{
    (void)preprocessed;
    (void)output_path;
    // FILE* out_file = open_out_file(output_path);
    // fclose(out_file);
}

static char* compile(Token* preprocessed, char* input_path)
{
    char* output_path;
    if(args.mode < MODE_COMPILE)
        return NULL;
    else if(args.mode == MODE_COMPILE)
        output_path = args.output_file == NULL ? 
                        convert_ext_to(input_path, FT_ASM) : 
                        args.output_file;
    else
        output_path = create_tempfile();


    printf("\n\033[35;1mPARSER:\033[0m\n");
    Object* program = parse_tokens(preprocessed);
    print_program(program);

    printf("\n\033[35;1mCODEGEN:\033[0m\n");
    gen_intermediate_rep(program, input_path, output_path);
    return output_path;
}

static char* assemble(char* input_path)
{
    char* output_path;
    if(args.mode < MODE_ASSEMBLE)
        return NULL;
    else if(args.mode == MODE_ASSEMBLE)
        output_path = args.output_file == NULL ? 
                        convert_ext_to(input_path, FT_OBJ) : 
                        args.output_file;
    else
        output_path = create_tempfile();

    assemble_intermediate(input_path, output_path);

    return output_path;
}


static char* create_tempfile(void)
{
    static const char template[] = "/tmp/siliconc-XXXXXX";
    char* res = malloc(sizeof(template));
    memcpy(res, template, sizeof(template));
    int fd = mkstemp(res);
    if(fd == -1)
        sic_error_fatal("Failed to create temporary file.");

    close(fd);
    da_append(&s_tempfiles, res);
    return res;
}

static void close_tempfiles(void)
{
    for(size_t i = 0; i < s_tempfiles.size; ++i)
        unlink(s_tempfiles.data[i]);
}
