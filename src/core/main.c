#include "internal.h"
#include "backend/codegen.h"
#include "utils/debug.h"
#include "utils/file_utils.h"
#include "utils/lib.h"

#include <errno.h>
#include <glob.h>
#include <unistd.h>
#include <sys/wait.h>

CompilerContext g_compiler = {.top_module = {.name = "default"}};

static void compile(const SIFile* input);
static void resolve_dependency_paths(char** crt, char** gcclib);

#ifdef SI_DEBUG
#define DBG_OUTPUT(x) if(g_args.emit_debug_output) x

static void print_debug_stats() { printf("\nMemory Allocated: %zu bytes\n", global_arena_allocated()); }

#else // !SI_DEBUG
#define DBG_OUTPUT(x)
#endif // SI_DEBUG

int main(int argc, char* argv[])
{
    if(argc < 1)
        SIC_UNREACHABLE();

    global_arenas_init();
    process_cmdln_args(argc, argv);
    
    for(size_t i = 0; i < g_args.input_files.size; ++i)
        if(!sifile_exists(g_args.input_files.data + i))
            sic_fatal_error("File named '%s' not found.", g_args.input_files.data[i].full_path);

    sym_map_init();
    parser_init();
    atexit(close_tempfiles); // Close all tempfiles opened when we exit for any reason
    DBG_OUTPUT(atexit(print_debug_stats));

    if(g_args.ir_kind == IR_LLVM)
        llvm_initialize();

    for(size_t i = 0; i < g_args.input_files.size; ++i)
    {
        SIFile* cur_input = g_args.input_files.data + i; 
        
        switch(cur_input->type)
        {
        case FT_SI:
            compile(cur_input);
            continue;
        case FT_LLVM_IR:
        case FT_ASM:
            SIC_TODO();
            continue;
        case FT_OBJ:
            if(g_args.mode == MODE_LINK)
                da_append(&g_compiler.linker_inputs, *cur_input);
            else
                fprintf(stderr, "Object file \'%s\' was ignored because \'-c\' or \'-s\' was provided.\n", cur_input->full_path);
            continue;
        case FT_UNKNOWN:
        case FT_SHARED:
        case FT_STATIC:
            sic_fatal_error("Input file \'%s\' has invalid extension.", cur_input->full_path);
        }
        SIC_UNREACHABLE();
    }

    semantic_analysis(&g_compiler.modules_to_compile);

    if(g_error_cnt > 0)
    {
        fprintf(stderr, "sic: ");
        if(g_warning_cnt > 0)
            fprintf(stderr, "%d warning(s), and ", g_warning_cnt);
        fprintf(stderr, "%d error(s) generated. Compilation terminated.\n", g_error_cnt); 
        exit(EXIT_FAILURE);
    }
    if(g_warning_cnt > 0)
        fprintf(stderr, "sic: %d warning(s) generated.\n", g_warning_cnt); 

    if(g_compiler.modules_to_compile.size == 0)
        exit(EXIT_SUCCESS);

    gen_ir(&g_compiler.modules_to_compile);

    if(g_args.mode != MODE_LINK || g_compiler.linker_inputs.size == 0)
        exit(EXIT_SUCCESS);


    // Link the object files generated by the assembly step into the
    // final output for the architecture specified in the command line.

    char* crt_path;
    char* gcc_path;
    resolve_dependency_paths(&crt_path, &gcc_path);

    StringDA cmd;
    da_init(&cmd, 20 + g_compiler.linker_inputs.size); // The 20 is how many appends will be done
    da_append(&cmd, "ld");
    da_append(&cmd, "-m");
    da_append(&cmd, "elf_x86_64");
    da_append(&cmd, "-pie");
    da_append(&cmd, "-dynamic-linker");
    da_append(&cmd, "/lib64/ld-linux-x86-64.so.2");
    da_append(&cmd, "-o");
    da_append(&cmd, g_args.output_file ? (char*)g_args.output_file : "a.out");

    // CRT Object files
    da_append(&cmd, str_format("%s/Scrt1.o", crt_path));
    da_append(&cmd, str_format("%s/crti.o", crt_path));
    da_append(&cmd, str_format("%s/crtbeginS.o", gcc_path));

    // Default library path includes
    da_append(&cmd, str_format("-L%s", gcc_path));
    da_append(&cmd, "-L/lib../lib");
    da_append(&cmd, "-L/usr/lib/../lib");
    da_append(&cmd, "-L/lib");
    da_append(&cmd, "-L/usr/lib");

    for(size_t i = 0; i < g_compiler.linker_inputs.size; ++i)
        da_append(&cmd, (char*)g_compiler.linker_inputs.data[i].full_path);

    da_append(&cmd, "-lc");

    da_append(&cmd, str_format("%s/crtendS.o", gcc_path));
    da_append(&cmd, str_format("%s/crtn.o", crt_path));

    da_append(&cmd, NULL);
    run_subprocess(cmd.data);

    return EXIT_SUCCESS;
}

void run_subprocess(char** cmd)
{
    if(g_args.hash_hash_hash)
    {
        for(char** c = cmd; *c != NULL; ++c)
            printf("%s ", *c);
        putc('\n', stdout);
    }
    if(fork() == 0)
    {
        execvp(cmd[0], cmd);
        fprintf(stderr, "failed to execute subprocess \'%s\': %s\n", cmd[0], strerror(errno));
        _exit(EXIT_FAILURE);
    }

    int status;
    while(wait(&status) > 0)
        ;
    if(status != EXIT_SUCCESS)
        exit(status);
}

static void compile(const SIFile* input)
{
    CompilationUnit* unit = CALLOC_STRUCT(CompilationUnit);

    unit->file = *input;

    DBG_OUTPUT({
        CompilationUnit debug_unit = *unit;
        Lexer debug_lexer;
        lexer_init_unit(&debug_lexer, &debug_unit);
        print_all_tokens(&debug_lexer);
    });
    parse_unit(unit);
    DBG_OUTPUT({
        print_unit(unit);
        printf("\n\n\n");
    })

    semantic_declaration(unit);
}

static void resolve_dependency_paths(char** crt, char** gcclib)
{
    if(file_exists("/usr/lib/x86_64-linux-gnu/crti.o"))
        *crt = "/usr/lib/x86_64-linux-gnu";
    else if(file_exists("/usr/lib64/crti.o"))
        *crt = "/usr/lib64";
    else
        sic_fatal_error("Unable to locate the CRT (C Runtime Libraries).");

    char* gcc_locations[] = {
        "/usr/lib/gcc/x86_64-linux-gnu/*/crtbegin.o",
        "/usr/lib/gcc/x86_64-pc-linux-gnu/*/crtbegin.o",
        "/usr/lib/gcc/x86_64-redhat-linux/*/crtbegin.o",
    };
    for(size_t i = 0; i < sizeof(gcc_locations) / sizeof(gcc_locations[0]); ++i)
    {
        glob_t buf;
        glob(gcc_locations[i], 0, NULL, &buf);
        if (buf.gl_pathc > 0)
        {
            char* cur = buf.gl_pathv[buf.gl_pathc - 1];
            size_t len = strrchr(cur, '/') - cur;
            *gcclib = cmalloc(len + 1);
            memcpy(*gcclib, cur, len);
            (*gcclib)[len] = '\0';
            globfree(&buf);
            return;
        }
        globfree(&buf);
    }
    sic_fatal_error("Unable to locate GCC libraries.");
}

