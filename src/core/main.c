#define _POSIX_C_SOURCE 200809L
#include "cmdline.h"
#include "core.h"
#include "lexer.h"
#include "parser.h"
#include "backend/codegen.h"
#include "utils/debug.h"
#include "utils/error.h"
#include "utils/file_utils.h"
#include "utils/hash.h"

#include <errno.h>
#include <glob.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

static void  output_preprocessed(Token* preprocessed, char* output_path);
static char* compile(Token* preprocessed, char* input_path);
static char* assemble(char* input_path);
static char* create_tempfile(FileType ft);
static void  close_tempfiles(void);
static void  resolve_dependency_paths(char** crt, char** gcclib);
static char* format_new(const char* restrict format, ...);

static StringArray s_tempfiles;

int main(int argc, char* argv[])
{
    if(argc < 1)
        sic_error_fatal("Bad arguments.");
    
    process_cmdln_args(argc, argv);
    
    for(size_t i = 0; i < args.input_files.size; ++i)
        if(!file_exists(args.input_files.data[i]))
            sic_error_fatal("File named '%s' not found.", args.input_files.data[i]);

    init_parser();
    da_init(&s_tempfiles, args.input_files.size);
    atexit(close_tempfiles); // Close all tempfiles opened when we exit for any reason

    StringArray linker_inputs;
    da_init(&linker_inputs, args.input_files.size);

    for(size_t i = 0; i < args.input_files.size; ++i)
    {
        char* cur_input_path     = args.input_files.data[i];
        char* cur_input_filename = strrchr(cur_input_path, '/');
        char* cur_output_path    = NULL;

        FileType ft = get_filetype(cur_input_filename);

        if(ft == FT_SI)
        {
            printf("\n\033[35;1mLEXER:\033[0m\n");
            Token* tokens = lex_file(cur_input_path);
            print_all_tokens(tokens);

            if(tokens->type == TOKEN_EOF)
            {
                fprintf(stderr, "Ignoring translation unit \'%s\' because it was empty.\n", cur_input_path);
                continue;
            }

            if(args.mode == MODE_PREPROCESS)
            {
                output_preprocessed(tokens, args.output_file);
                continue;
            }

            cur_output_path = compile(tokens, cur_input_path);
            if(args.mode >= MODE_ASSEMBLE && !sic_has_error())
                cur_output_path = assemble(cur_output_path);
        }
        else if(ft == FT_ASM)
        {
            if(args.mode >= MODE_ASSEMBLE)
                cur_output_path = assemble(cur_input_path);
            else
                fprintf(stderr, "Assembly file \'%s\' was ignored because \'-p\' or \'-c\' was provided.\n", cur_input_path);
        }
        else if(ft == FT_OBJ)
        {
            if(args.mode == MODE_LINK)
                cur_output_path = cur_input_path;
            else
                fprintf(stderr, "Object file \'%s\' was ignored because \'-p\', \'-c\', or \'-s\' was provided.\n", cur_input_path);
        }
        else
            sic_error_fatal("Input file \'%s\' has invalid extension.", cur_input_path);

        if(args.mode == MODE_LINK && cur_output_path != NULL)
            da_append(&linker_inputs, cur_output_path);
    }

    if(args.mode != MODE_LINK || linker_inputs.size == 0)
        return EXIT_SUCCESS;

    // Link the object files generated by the assembly step into the
    // final output for the architecture specified in the command line.

    char* crt_path;
    char* gcc_path;
    resolve_dependency_paths(&crt_path, &gcc_path);

    StringArray cmd;
    da_append(&cmd, "ld");
    da_append(&cmd, "-m");
    da_append(&cmd, "elf_x86_64"); // Change this to depend on the target architecture
    da_append(&cmd, "-pie");
    da_append(&cmd, "-dynamic-linker");
    da_append(&cmd, "/lib64/ld-linux-x86-64.so.2");
    da_append(&cmd, "-o");
    da_append(&cmd, args.output_file ? (char*)args.output_file : "a.out");

    // CRT Object files
    da_append(&cmd, format_new("%s/Scrt1.o", crt_path));
    da_append(&cmd, format_new("%s/crti.o", crt_path));
    da_append(&cmd, format_new("%s/crtbeginS.o", gcc_path));

    // Default library path includes
    da_append(&cmd, format_new("-L%s", gcc_path));
    da_append(&cmd, "-L/lib../lib");
    da_append(&cmd, "-L/usr/lib/../lib");
    da_append(&cmd, "-L/lib");
    da_append(&cmd, "-L/usr/lib");

    for(size_t i = 0; i < linker_inputs.size; ++i)
        da_append(&cmd, linker_inputs.data[i]);

    da_append(&cmd, "-lgcc");
    da_append(&cmd, "--push-state");
    da_append(&cmd, "--as-needed");
    da_append(&cmd, "-lgcc_s");
    da_append(&cmd, "--pop-state");
    da_append(&cmd, "-lc");
    da_append(&cmd, "-lgcc");
    da_append(&cmd, "--push-state");
    da_append(&cmd, "--as-needed");
    da_append(&cmd, "-lgcc_s");
    da_append(&cmd, "--pop-state");

    da_append(&cmd, format_new("%s/crtendS.o", gcc_path));
    da_append(&cmd, format_new("%s/crtn.o", crt_path));

    da_append(&cmd, NULL);
    run_subprocess(cmd.data);

    return EXIT_SUCCESS;
}

void run_subprocess(char** cmd)
{
    if(args.hash_hash_hash)
    {
        for(char** c = cmd; *c != NULL; ++c)
            printf("%s ", *c);
        putc('\n', stdout);
    }
    if(fork() == 0)
    {
        execvp(cmd[0], cmd);
        fprintf(stderr, "failed to execute subprocess \'%s\': %s\n", cmd[0], strerror(errno));
        _exit(EXIT_FAILURE);
    }

    int status;
    while(wait(&status) > 0)
        ;
    if(status != EXIT_SUCCESS)
        exit(status);
}

static void output_preprocessed(Token* preprocessed, char* output_path)
{
    (void)preprocessed;
    (void)output_path;
    // FILE* out_file = open_out_file(output_path);
    // fclose(out_file);
}

static char* compile(Token* preprocessed, char* input_path)
{
    SIC_ASSERT(args.mode >= MODE_COMPILE);
    char* output_path;
    if(args.mode == MODE_COMPILE)
        output_path = args.output_file == NULL ? 
                        convert_ext_to(input_path, FT_ASM) : 
                        args.output_file;
    else
        output_path = create_tempfile(FT_ASM);


    printf("\n\033[35;1mPARSER:\033[0m\n");
    Object* program = parse_tokens(preprocessed);
    print_program(program);

    printf("\n\033[35;1mCODEGEN:\033[0m\n");
    gen_intermediate_rep(program, input_path, output_path);
    return output_path;
}

static char* assemble(char* input_path)
{
    SIC_ASSERT(args.mode >= MODE_ASSEMBLE);
    char* output_path;
    if(args.mode == MODE_ASSEMBLE)
        output_path = args.output_file == NULL ? 
                        convert_ext_to(input_path, FT_OBJ) : 
                        args.output_file;
    else
        output_path = create_tempfile(FT_OBJ);

    assemble_intermediate(input_path, output_path);

    return output_path;
}


static char* create_tempfile(FileType ft)
{
    static const char template[] = "/tmp/siliconc-XXXXXX";
    const char* ext = ft_to_extension(ft);
    size_t ext_len = strlen(ext);
    char* res = malloc(sizeof(template) + ext_len);
    memcpy(res, template, sizeof(template));
    int fd = mkstemp(res);
    if(fd == -1)
        sic_error_fatal("Failed to create temporary file.");

    close(fd);
    memcpy(res + sizeof(template) - 1, ext, ext_len);
    res[sizeof(template) + ext_len - 1] = '\0';
    da_append(&s_tempfiles, res);
    return res;
}

static void close_tempfiles(void)
{
    for(size_t i = 0; i < s_tempfiles.size; ++i)
        unlink(s_tempfiles.data[i]);
}

static void resolve_dependency_paths(char** crt, char** gcclib)
{
    if(file_exists("/usr/lib/x86_64-linux-gnu/crti.o"))
        *crt = "/usr/lib/x86_64-linux-gnu";
    else if(file_exists("/usr/lib64/crti.o"))
        *crt = "/usr/lib64";
    else
        sic_error_fatal("Unable to locate the CRT (C Runtime Libraries).");

    char* gcc_locations[] = {
        "/usr/lib/gcc/x86_64-linux-gnu/*/crtbegin.o",
        "/usr/lib/gcc/x86_64-pc-linux-gnu/*/crtbegin.o",
        "/usr/lib/gcc/x86_64-redhat-linux/*/crtbegin.o",
    };
    for(size_t i = 0; i < sizeof(gcc_locations) / sizeof(gcc_locations[0]); ++i)
    {
        glob_t buf;
        glob(gcc_locations[i], 0, NULL, &buf);
        if (buf.gl_pathc > 0)
        {
            *gcclib = strdup(buf.gl_pathv[buf.gl_pathc - 1]);
            globfree(&buf);
            *strrchr(*gcclib, '/') = '\0';
            return;
        }
        globfree(&buf);
    }
    sic_error_fatal("Unable to locate GCC libraries.");
}

static char* format_new(const char* restrict format, ...)
{
    va_list va;
    va_start(va, format);
    int size = vsnprintf(NULL, 0, format, va);
    va_end(va);

    char* buf = malloc(size + 1);

    va_start(va, format);
    vsnprintf(buf, size + 1, format, va);
    va_end(va);
    buf[size] = '\0';
    return buf;
}
