#include "cmdline.h"
#include "core.h"
#include "lexer.h"
#include "parser.h"
#include "backend/codegen.h"
#include "utils/debug.h"
#include "utils/error.h"
#include "utils/file_utils.h"
#include "utils/hash.h"

int main(int argc, char* argv[])
{
    if(argc < 1)
        sic_error_fatal("Bad arguments.");
    
    process_cmdln_args(argc, argv);
    
    for(size_t i = 0; i < args.input_files.size; ++i)
        if(!file_exists(args.input_files.data[i]))
            sic_error_fatal("File named '%s' not found.", args.input_files.data[i]);

    init_parser();

    for(size_t i = 0; i < args.input_files.size; ++i)
    {
        char* file = args.input_files.data[i];
        // FileType ft = get_filetype(args.input_files.data[i]);

        // Lex the file and preprocess the results.
        printf("\n\033[35;1mLEXER:\033[0m\n");

        Token* tokens = lex_file(file);
        print_all_tokens(tokens);

        if(args.mode < MODE_COMPILE)
            continue;

        // Compile the preprocessed tokens into an AST, and convert the
        // AST into the intermediate representation specified by the 
        // command line arguments.
        printf("\n\033[35;1mPARSER:\033[0m\n");
        Object* program = parse_tokens(tokens);
        if(program == NULL)
        {
            printf("Empty translation unit \'%s\'.", file);
            continue;
        }

        print_program(program);

        char* filename = strrchr(file, '/');
        if(filename == NULL)
            filename = file;
        else
            filename++;

        printf("\n\033[35;1mCODEGEN:\033[0m\n");
        gen_intermediate_rep(stdout, program, filename);

        if(args.mode < MODE_ASSEMBLE)
            continue;

        // Transform the intermediate representation generated by the
        // compilation step into an object file, or whatever the output
        // should be depending on the intermediate representation.


    }

    if(args.mode == MODE_LINK)
    {
        // Link the object files generated by the assembly step into the
        // final output for the architecture specified in the command line.
    }
    return EXIT_SUCCESS;
}
